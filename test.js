'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.m = exports.lookupResponse = exports.clear = exports.uninstall = exports.install = exports.mockRequest = exports.mockClient = undefined;

var _mockRequest = require('./mocks/mock-request');

var _mockRequest2 = _interopRequireDefault(_mockRequest);

var _mockResource = require('./mocks/mock-resource');

var _mockResource2 = _interopRequireDefault(_mockResource);

var _mock = require('./gateway/mock');

var _mock2 = _interopRequireDefault(_mock);

var _index = require('./index');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var store = [];
var ids = 1;
var originalGateway = null;

/**
 * High level abstraction, it works directly on your client mocking
 * the resources and their methods.
 * @param {Object} client - the client generated by {@link forge}
 *
 * @return {MockAssert}
 */
var mockClient = exports.mockClient = function mockClient(client) {
  var entry = new _mockResource2.default(ids++, client);
  store.push(entry);
  return entry;
};

/**
 * Low level abstraction, very useful for automations
 * @param {Object} props
 *   @param {String} props.method - request method (get, post, etc)
 *   @param {String} props.url - request url (http://example.com)
 *   @param {String} props.body - request body
 *   @param {String} props.response
 *     @param {String} props.response.status
 *     @param {String} props.response.headers
 *     @param {String} props.response.body
 *
 * @return {MockAssert}
 */
var mockRequest = exports.mockRequest = function mockRequest(props) {
  var entry = new _mockRequest2.default(ids++, props);
  store.push(entry);
  return entry.assertObject();
};

/**
 * Setup the test library
 */
var install = exports.install = function install() {
  originalGateway = _index.configs.gateway;
  _index.configs.gateway = _mock2.default;
};

/**
 * Teardown the test library
 */
var uninstall = exports.uninstall = function uninstall() {
  clear();
  if (originalGateway) {
    _index.configs.gateway = originalGateway;
    originalGateway = null;
  }
};

/**
 * Cleans up all mocks
 */
var clear = exports.clear = function clear() {
  store = [];
};

/**
 * @param {Request} request
 * @return {Response}
 * @throws Will throw an error if it doesn't find a mock to match the given request
 */
var lookupResponse = exports.lookupResponse = function lookupResponse(request) {
  var mocks = store.map(function (mock) {
    return mock.toMockRequest();
  });

  var exactMatch = mocks.filter(function (mock) {
    return mock.isExactMatch(request);
  }).pop();

  if (exactMatch) {
    return exactMatch.call(request);
  }

  var partialMatch = mocks.filter(function (mock) {
    return mock.isPartialMatch(request);
  }).pop();

  if (partialMatch) {
    throw new Error('[Mappersmith Test] No exact match found for ' + requestToLog(request) + ', partial match with ' + mockToLog(partialMatch) + ', check your mock definition');
  }

  throw new Error('[Mappersmith Test] No match found for ' + requestToLog(request) + ', check your mock definition');
};

/**
 * List of match functions
 */
var m = exports.m = {
  stringMatching: function stringMatching(regexp) {
    if (!(regexp instanceof RegExp)) {
      throw new Error('[Mappersmith Test] "stringMatching" received an invalid regexp (' + regexp + ')');
    }
    return function (string) {
      return regexp.test(string);
    };
  },

  stringContaining: function stringContaining(sample) {
    if (typeof sample !== 'string') {
      throw new Error('[Mappersmith Test] "stringContaining" received an invalid string (' + sample + ')');
    }

    return function (string) {
      return stringIncludes(string, sample);
    };
  },

  uuid4: function uuid4() {
    // NOTE: based on https://github.com/chriso/validator.js/blob/3443132beccddf06c3f0a5e88c1dd2ee6513b612/src/lib/isUUID.js
    var uuid4Rx = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;

    return function (string) {
      return uuid4Rx.test(string);
    };
  },

  anything: function anything() {
    return function () {
      return true;
    };
  }
};

var requestToLog = function requestToLog(request) {
  return '"' + request.method().toUpperCase() + ' ' + request.url() + '" (body: "' + (0, _utils.toQueryString)(request.body()) + '")';
};
var mockToLog = function mockToLog(requestMock) {
  return '"' + requestMock.method.toUpperCase() + ' ' + requestMock.url + '" (body: "' + requestMock.body + '")';
};

var stringIncludes = function stringIncludes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (typeof str.includes === 'function') {
    return str.includes(search, start);
  }

  if (start + search.length > str.length) {
    return false;
  }

  return str.indexOf(search, start) !== -1;
};